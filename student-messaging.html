<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Messages - FunaGig</title>
    <link rel="stylesheet" href="css/styles.css" />
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <header class="navbar">
        <div class="brand">
            <div class="logo"></div> FunaGig
        </div>
    </header>
    <div class="app-layout">
        <aside class="sidebar">
            <div class="title" style="display:flex; align-items:center; gap:10px;">
                <div class="cover-img" style="width:36px;height:36px;">AP</div> Amanya Peter
            </div>
            <nav class="navlist">
                <a class="navitem" href="student-dashboard.html">Dashboard</a>
                <a class="navitem" href="student-gigs.html">Gigs</a>
                <a class="navitem active" href="student-messaging.html">Messages</a>
                <a class="navitem" href="student-profile.html">Profile</a>
                <a class="navitem" href="index.html">Log out</a>
            </nav>
        </aside>
        <main class="messaging-container">
            <!-- Existing messaging content from document -->
            <div class="conversations-sidebar">
                <div class="conversations-header">
                    <h2>Messages</h2>
                    <input type="text" placeholder="Search..." />
                </div>
                <div id="conversationsList" class="conversations-list">
                    <!-- JS-loaded -->
                </div>
            </div>
            <div class="chat-area">
                <div id="chatHeader" class="chat-header" style="display:none;">
                    <div class="chat-user-info">
                        <div id="chatUserAvatar" class="chat-user-avatar">B</div>
                        <div class="chat-user-details">
                            <h3 id="chatUserName">Employer</h3>
                            <p id="chatUserEmail">email@example.com</p>
                        </div>
                    </div>
                    <div class="chat-actions" style="display: flex; gap: 10px; align-items: center;">
                        <div class="message-search-container" style="position: relative;">
                            <input type="text" id="messageSearchInput" class="input" placeholder="Search messages..." style="width: 200px; padding: 8px 30px 8px 12px; font-size: 13px;" />
                            <span style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); color: var(--muted); pointer-events: none;">üîç</span>
                            <div id="messageSearchResults" style="display: none; position: absolute; top: 100%; right: 0; background: white; border: 1px solid var(--border); border-radius: 8px; padding: 8px; margin-top: 4px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 100; max-width: 300px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <span class="subtle" style="font-size: 12px;" id="searchResultsCount">0 results</span>
                                    <div style="display: flex; gap: 4px;">
                                        <button class="btn-icon" id="prevSearchResult" onclick="navigateSearchResult(-1)" style="padding: 4px 8px; font-size: 12px;" title="Previous">‚Üë</button>
                                        <button class="btn-icon" id="nextSearchResult" onclick="navigateSearchResult(1)" style="padding: 4px 8px; font-size: 12px;" title="Next">‚Üì</button>
                                        <button class="btn-icon" id="closeSearch" onclick="closeMessageSearch()" style="padding: 4px 8px; font-size: 12px;" title="Close">√ó</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button onclick="viewGigDetails()">View Gig</button>
                        <button onclick="reportEmployer()">Report</button>
                    </div>
                </div>
                <div id="chatMessages" class="chat-messages">
                    <div id="typingIndicator" class="typing-indicator" style="display: none;">
                        <div class="typing-dots">
                            <span></span><span></span><span></span>
                        </div>
                        <span class="typing-text"></span>
                    </div>
                    <div class="no-conversation">
                        <h3>Select Conversation</h3>
                        <p>Chats start when employer messages you.</p>
                    </div>
                </div>
                <div id="chatInputArea" class="chat-input-area" style="display:none;">
                    <div id="filePreview" class="file-preview-container" style="display:none;">
                        <div class="file-preview-item">
                            <span id="filePreviewName" class="file-preview-name"></span>
                            <button type="button" class="file-preview-remove" id="filePreviewRemove" onclick="removeSelectedFile()">√ó</button>
                        </div>
                    </div>
                    <div class="chat-input-row">
                        <input type="file" id="fileInput" accept="image/*,application/pdf,.doc,.docx,.txt" style="display:none;" />
                        <button class="btn-icon" id="attachBtn" onclick="document.getElementById('fileInput').click()" title="Attach File">üìé</button>
                        <textarea id="messageInput" placeholder="Type message..." rows="1"></textarea>
                        <button id="sendBtn" class="btn-icon" onclick="sendMessage()" title="Send">‚û§</button>
                    </div>
                </div>
            </div>
        </main>
    </div>
    <script src="js/app.js"></script>
    <script>
        // Global variables for real-time updates
        let messagePollInterval = null;
        let conversationPollInterval = null;
        let currentConversationId = null;
        let allMessages = []; // Store all messages for client-side search
        let searchResults = []; // Store search results
        let currentSearchIndex = -1; // Current highlighted search result
        
        // Load user data and update sidebar
        document.addEventListener('DOMContentLoaded', async function() {
            // Verify session and check user type
            if (!Auth.requireUserType('student')) {
                return;
            }
            
            // Verify session is still valid
            const user = await Auth.verifySession();
            if (!user) {
                return; // verifySession already handles logout/redirect
            }
            
            if (user) {
                // Update user name in sidebar
                const userName = user.name;
                const userInitials = userName.split(' ').map(n => n[0]).join('').toUpperCase();
                
                // Update sidebar
                const sidebarTitle = document.querySelector('.sidebar .title');
                if (sidebarTitle) {
                    sidebarTitle.innerHTML = `<div class="cover-img" style="width:36px;height:36px;">${userInitials}</div> ${userName}`;
                }
                
                // Load conversations
                loadConversations();
                
                // Poll conversations every 10 seconds to check for new messages
                conversationPollInterval = setInterval(() => {
                    loadConversations();
                }, 10000);
                
                // Setup file input handler
                const fileInput = document.getElementById('fileInput');
                let selectedFile = null;
                
                if (fileInput) {
                    fileInput.addEventListener('change', function(e) {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        // Validate file size (5MB)
                        if (file.size > 5 * 1024 * 1024) {
                            Toast.error('File size must be less than 5MB');
                            fileInput.value = '';
                            return;
                        }
                        
                        // Show file preview
                        selectedFile = file;
                        const filePreview = document.getElementById('filePreview');
                        const filePreviewName = document.getElementById('filePreviewName');
                        
                        if (filePreview && filePreviewName) {
                            filePreviewName.textContent = file.name;
                            filePreview.style.display = 'block';
                        }
                    });
                }
                
                // Make selectedFile accessible globally
                window.selectedFile = null;
                window.removeSelectedFile = function() {
                    selectedFile = null;
                    window.selectedFile = null;
                    const fileInput = document.getElementById('fileInput');
                    const filePreview = document.getElementById('filePreview');
                    if (fileInput) fileInput.value = '';
                    if (filePreview) filePreview.style.display = 'none';
                };
            }
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (messagePollInterval) {
                clearInterval(messagePollInterval);
            }
            if (conversationPollInterval) {
                clearInterval(conversationPollInterval);
            }
        });
        
        async function loadConversations() {
            try {
                const response = await apiFetch('/conversations', {
                    silent: !!conversationPollInterval, // Don't show error notifications during polling
                    retry: false // Disable retry for polling to avoid delays
                });
                if (response.success) {
                    updateConversationsList(response.conversations);
                }
            } catch (error) {
                console.error('Failed to load conversations:', error);
                // Error notification is handled by apiFetch if not silent
            }
        }
        
        function updateConversationsList(conversations) {
            const conversationsList = document.getElementById('conversationsList');
            if (conversationsList && conversations) {
                conversationsList.innerHTML = conversations.map(conv => {
                    const unreadCount = conv.unread_count || 0;
                    const unreadClass = unreadCount > 0 ? 'unread' : '';
                    const lastMessageTime = conv.last_message_time ? 
                        formatMessageTime(conv.last_message_time) : '';
                    
                    return `
                        <div class="conversation-item ${unreadClass}" data-conversation-id="${conv.id}" onclick="selectConversation(${conv.id})">
                            <div class="conversation-avatar">${(conv.other_user_name || 'U').charAt(0).toUpperCase()}</div>
                        <div class="conversation-content">
                                <div class="conversation-name">${escapeHtml(conv.other_user_name || 'User')}</div>
                                <div class="conversation-preview">${escapeHtml((conv.last_message || 'No messages yet').substring(0, 50))}${(conv.last_message || '').length > 50 ? '...' : ''}</div>
                        </div>
                        <div class="conversation-meta">
                                <div class="conversation-time">${lastMessageTime}</div>
                                ${unreadCount > 0 ? `<div class="unread-badge">${unreadCount > 99 ? '99+' : unreadCount}</div>` : ''}
                            </div>
                        </div>
                    `;
                }).join('');
            }
        }
        
        function formatMessageTime(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function selectConversation(conversationId) {
            // Leave previous conversation room if any
            if (currentConversationId && WebSocketClient.isConnected()) {
                WebSocketClient.leaveConversation(currentConversationId);
            }
            
            // Set current conversation
            currentConversationId = conversationId;
            
            // Remove unread styling from selected conversation
            document.querySelectorAll('.conversation-item').forEach(item => {
                if (parseInt(item.dataset.conversationId) === conversationId) {
                    item.classList.remove('unread');
                    const badge = item.querySelector('.unread-badge');
                    if (badge) badge.remove();
                }
            });
            
            // Clear previous polling
            if (messagePollInterval) {
                clearInterval(messagePollInterval);
                messagePollInterval = null;
            }
            
            // Load messages for this conversation
            loadMessages(conversationId);
            
            // Join WebSocket conversation room
            if (WebSocketClient.isConnected()) {
                WebSocketClient.joinConversation(conversationId);
                // Setup WebSocket event handlers
                setupWebSocketHandlers(conversationId);
                // Mark messages as read via WebSocket
                WebSocketClient.markMessagesRead(conversationId);
            }
            
            // Fallback: Start polling if WebSocket is not connected
            if (!WebSocketClient.isConnected()) {
                messagePollInterval = setInterval(() => {
                    if (currentConversationId) {
                        loadMessages(currentConversationId);
                    }
                }, 3000);
            }
        }
        
        async function loadMessages(conversationId) {
            try {
                const response = await apiFetch(`/messages/${conversationId}`, {
                    silent: !!messagePollInterval, // Don't show error notifications during polling
                    retry: false // Disable retry for polling to avoid delays
                });
                if (response.success) {
                    updateMessagesList(response.messages);
                    showChatArea();
                    
                    // Auto-scroll to bottom
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages) {
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }
            } catch (error) {
                console.error('Failed to load messages:', error);
                // Error notification is handled by apiFetch if not silent
            }
        }
        
        function updateMessagesList(messages) {
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages && messages) {
                // Store messages for search
                allMessages = messages;
                
                const currentUserId = getCurrentUserId();
                const searchTerm = document.getElementById('messageSearchInput')?.value.trim() || '';
                
                chatMessages.innerHTML = messages.map((msg, index) => {
                    const isOwnMessage = msg.sender_id === currentUserId;
                    const senderInitials = (msg.sender_name || 'U').charAt(0).toUpperCase();
                    const messageTime = formatMessageTime(msg.created_at);
                    const attachments = msg.attachments || [];
                    
                    // Highlight search term in message content
                    let messageContent = msg.content || '';
                    let isSearchResult = false;
                    if (searchTerm && messageContent.toLowerCase().includes(searchTerm.toLowerCase())) {
                        isSearchResult = true;
                        const regex = new RegExp(`(${escapeRegex(searchTerm)})`, 'gi');
                        messageContent = messageContent.replace(regex, '<mark class="search-highlight">$1</mark>');
                    } else {
                        messageContent = escapeHtml(messageContent);
                    }

                    // Render attachments
                    let attachmentsHtml = '';
                    if (attachments.length > 0) {
                        attachmentsHtml = attachments.map(att => {
                            const isImage = att.file_type && ['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(att.file_type.toLowerCase());
                            const fileUrl = att.file_url || ('/' + att.file_path);
                            const fileSize = att.file_size ? formatFileSize(att.file_size) : '';
                            
                            if (isImage) {
                                return `
                                    <div class="message-attachment">
                                        <a href="${fileUrl}" target="_blank" class="attachment-link">
                                            <img src="${fileUrl}" alt="${escapeHtml(att.file_name)}" class="attachment-image" />
                                        </a>
                                        <div class="attachment-info">
                                            <span class="attachment-name">${escapeHtml(att.file_name)}</span>
                                            ${fileSize ? `<span class="attachment-size">${fileSize}</span>` : ''}
                                        </div>
                                    </div>
                                `;
                            } else {
                                return `
                                    <div class="message-attachment">
                                        <a href="${fileUrl}" target="_blank" download="${escapeHtml(att.file_name)}" class="attachment-link">
                                            <div class="attachment-icon">üìÑ</div>
                                            <div class="attachment-info">
                                                <span class="attachment-name">${escapeHtml(att.file_name)}</span>
                                                ${fileSize ? `<span class="attachment-size">${fileSize}</span>` : ''}
                                            </div>
                                        </a>
                                    </div>
                                `;
                            }
                        }).join('');
                    }

                    const searchClass = isSearchResult ? ' search-result' : '';
                    const searchDataAttr = isSearchResult ? ` data-search-result="${index}"` : '';

                    return `
                        <div class="message ${isOwnMessage ? 'own' : ''}${searchClass}" data-message-id="${msg.id}"${searchDataAttr}>
                            ${!isOwnMessage ? `<div class="message-avatar">${senderInitials}</div>` : ''}
                        <div class="message-content">
                                ${messageContent ? `<div class="message-text">${messageContent}</div>` : ''}
                                ${attachmentsHtml ? `<div class="message-attachments">${attachmentsHtml}</div>` : ''}
                                <div class="message-time">${messageTime}</div>
                            </div>
                            ${isOwnMessage ? `<div class="message-avatar">${senderInitials}</div>` : ''}
                        </div>
                    `;
                }).join('');
                
                // Highlight current search result
                if (searchTerm && currentSearchIndex >= 0 && currentSearchIndex < searchResults.length) {
                    highlightSearchResult(currentSearchIndex);
                }
            }
        }
        
        // Escape regex special characters
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // Search messages within conversation
        function searchMessages(searchTerm) {
            if (!searchTerm || !allMessages.length) {
                searchResults = [];
                currentSearchIndex = -1;
                updateSearchResultsUI();
                // Re-render messages without highlighting
                updateMessagesList(allMessages);
                return;
            }
            
            const term = searchTerm.toLowerCase();
            searchResults = allMessages
                .map((msg, index) => ({ msg, index }))
                .filter(({ msg }) => {
                    const content = (msg.content || '').toLowerCase();
                    return content.includes(term);
                });
            
            currentSearchIndex = searchResults.length > 0 ? 0 : -1;
            updateSearchResultsUI();
            
            // Re-render messages with highlighting
            updateMessagesList(allMessages);
            
            // Scroll to first result
            if (searchResults.length > 0) {
                highlightSearchResult(0);
            }
        }
        
        // Update search results UI
        function updateSearchResultsUI() {
            const resultsContainer = document.getElementById('messageSearchResults');
            const resultsCount = document.getElementById('searchResultsCount');
            
            if (!resultsContainer || !resultsCount) return;
            
            if (searchResults.length > 0) {
                resultsCount.textContent = `${currentSearchIndex + 1} of ${searchResults.length} results`;
                resultsContainer.style.display = 'block';
                
                // Enable/disable navigation buttons
                const prevBtn = document.getElementById('prevSearchResult');
                const nextBtn = document.getElementById('nextSearchResult');
                if (prevBtn) prevBtn.disabled = currentSearchIndex <= 0;
                if (nextBtn) nextBtn.disabled = currentSearchIndex >= searchResults.length - 1;
            } else {
                const searchInput = document.getElementById('messageSearchInput');
                const searchTerm = searchInput ? searchInput.value.trim() : '';
                resultsCount.textContent = 'No results';
                resultsContainer.style.display = searchTerm ? 'block' : 'none';
            }
        }
        
        // Navigate search results
        function navigateSearchResult(direction) {
            if (searchResults.length === 0) return;
            
            currentSearchIndex += direction;
            if (currentSearchIndex < 0) currentSearchIndex = searchResults.length - 1;
            if (currentSearchIndex >= searchResults.length) currentSearchIndex = 0;
            
            updateSearchResultsUI();
            highlightSearchResult(currentSearchIndex);
        }
        
        // Highlight a specific search result
        function highlightSearchResult(index) {
            if (index < 0 || index >= searchResults.length) return;
            
            // Remove previous highlights
            document.querySelectorAll('.message.search-highlighted').forEach(msg => {
                msg.classList.remove('search-highlighted');
            });
            
            // Highlight current result
            const result = searchResults[index];
            const messageElement = document.querySelector(`[data-message-id="${result.msg.id}"]`);
            if (messageElement) {
                messageElement.classList.add('search-highlighted');
                messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        
        // Close message search
        function closeMessageSearch() {
            const searchInput = document.getElementById('messageSearchInput');
            const resultsContainer = document.getElementById('messageSearchResults');
            
            if (searchInput) searchInput.value = '';
            if (resultsContainer) resultsContainer.style.display = 'none';
            
            searchResults = [];
            currentSearchIndex = -1;
            
            // Re-render messages without highlighting
            if (allMessages.length > 0) {
                updateMessagesList(allMessages);
            }
        }
        
        // Setup message search
        function setupMessageSearch() {
            const searchInput = document.getElementById('messageSearchInput');
            if (!searchInput) return;
            
            // Debounced search
            const debouncedSearch = Debounce.create(() => {
                const searchTerm = searchInput.value.trim();
                searchMessages(searchTerm);
            }, 300);
            
            searchInput.addEventListener('input', debouncedSearch);
            
            // Keyboard shortcuts
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        navigateSearchResult(-1); // Shift+Enter for previous
                    } else {
                        navigateSearchResult(1); // Enter for next
                    }
                } else if (e.key === 'Escape') {
                    closeMessageSearch();
                    searchInput.blur();
                }
            });
        }
        
        // Format file size
        function formatFileSize(bytes) {
            if (!bytes) return '';
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        function showChatArea() {
            document.getElementById('chatHeader').style.display = 'flex';
            document.getElementById('chatInputArea').style.display = 'block';
            // Setup message search when chat area is shown
            setupMessageSearch();
        }
        
        function getCurrentUserId() {
            const user = Auth.getUser();
            return user ? user.id : null;
        }
        
        function getCurrentConversationId() {
            return currentConversationId;
        }
        
        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            if (!messageInput || !currentConversationId) return;

            const message = messageInput.value.trim();
            const file = window.selectedFile || selectedFile;
            
            // Must have either message or file
            if (!message && !file) return;

            const sendBtn = document.getElementById('sendBtn');
            const originalText = sendBtn?.textContent;
            if (sendBtn) {
                sendBtn.disabled = true;
                sendBtn.textContent = 'Sending...';
            }

            try {
                // First, send the message (even if empty, we need message_id for attachment)
                const messageText = message || (file ? `üìé ${file.name}` : '');
                
                const response = await apiFetch('/messages', {
                    method: 'POST',
                    body: JSON.stringify({
                        conversation_id: currentConversationId,
                        message: messageText
                    })
                });

                if (response.success && response.message_id) {
                    // If there's a file, upload it as attachment
                    if (file) {
                        try {
                            await FileUpload.upload(file, 'message', {
                                messageId: response.message_id
                            });
                        } catch (uploadError) {
                            console.error('File upload error:', uploadError);
                            Toast.error('Message sent but file upload failed: ' + (uploadError.message || 'Unknown error'));
                        }
                    }
                    
                    // Send WebSocket event for real-time update
                    const user = Auth.getUser();
                    if (WebSocketClient.isConnected() && user) {
                        WebSocketClient.sendMessageEvent(
                            currentConversationId,
                            response.message_id,
                            user.id,
                            messageText
                        );
                    }
                    
                    // Clear inputs
                    messageInput.value = '';
                    removeSelectedFile();
                    
                    // Reload messages immediately (WebSocket will also trigger update)
                    await loadMessages(currentConversationId);
                    // Also reload conversations to update last message
                    await loadConversations();
                } else {
                    Toast.error('Failed to send message');
                }
            } catch (error) {
                    console.error('Send message error:', error);
                Toast.error('Failed to send message: ' + (error.message || 'Unknown error'));
            } finally {
                if (sendBtn) {
                    sendBtn.disabled = false;
                    sendBtn.textContent = originalText || '‚û§';
                }
            }
        }
        
        // Typing indicator functionality
        let typingTimeout = null;
        let typingPollInterval = null;
        let isTyping = false;
        let lastTypingSent = 0;
        let currentConversationWebSocketHandlers = null;
        
        // Setup typing detection
        function setupTypingIndicator() {
            const messageInput = document.getElementById('messageInput');
            if (!messageInput) return;
            
            // Debounced function to send typing status
            const sendTypingStatus = Debounce.create((typing) => {
                if (!currentConversationId) return;
                
                const now = Date.now();
                // Throttle: only send typing status every 2 seconds
                if (typing && (now - lastTypingSent < 2000)) return;
                
                lastTypingSent = now;
                isTyping = typing;
                
                apiFetch('/typing', {
                    method: 'POST',
                    body: JSON.stringify({
                        conversation_id: currentConversationId,
                        is_typing: typing
                    }),
                    silent: true,
                    retry: false
                }).catch(err => {
                    // Silently fail - typing indicator is not critical
                    console.warn('Failed to send typing status:', err);
                });
            }, 500);
            
            // Detect typing
            messageInput.addEventListener('input', () => {
                if (!currentConversationId) return;
                
                const user = Auth.getUser();
                const userName = user ? user.name : 'User';
                
                // Use WebSocket if available, otherwise fallback to API
                if (WebSocketClient.isConnected()) {
                    WebSocketClient.sendTyping(currentConversationId, true, userName);
                    
                    // Clear existing timeout
                    if (typingTimeout) {
                        clearTimeout(typingTimeout);
                    }
                    
                    // Set timeout to send typing = false after 3 seconds of no typing
                    typingTimeout = setTimeout(() => {
                        WebSocketClient.sendTyping(currentConversationId, false, userName);
                    }, 3000);
                } else {
                    // Fallback to API
                    sendTypingStatus(true);
                    
                    // Clear existing timeout
                    if (typingTimeout) {
                        clearTimeout(typingTimeout);
                    }
                    
                    // Set timeout to send typing = false after 3 seconds of no typing
                    typingTimeout = setTimeout(() => {
                        sendTypingStatus(false);
                    }, 3000);
                }
            });
        }
        
        // Setup WebSocket event handlers for messaging
        function setupWebSocketHandlers(conversationId) {
            // Remove previous handlers if any
            if (currentConversationWebSocketHandlers) {
                Object.keys(currentConversationWebSocketHandlers).forEach(event => {
                    WebSocketClient.off(event, currentConversationWebSocketHandlers[event]);
                });
            }
            
            currentConversationWebSocketHandlers = {};
            
            // Handle new message received
            const messageHandler = (data) => {
                if (data.conversationId === conversationId) {
                    // Reload messages to show new message
                    loadMessages(conversationId);
                    
                    // Play notification sound (optional)
                    // Show notification if not in current conversation
                    if (data.conversationId !== currentConversationId) {
                        Toast.info('New message received');
                    }
                }
            };
            WebSocketClient.on('message_received', messageHandler);
            currentConversationWebSocketHandlers['message_received'] = messageHandler;
            
            // Handle typing indicator
            const typingHandler = (data) => {
                if (data.conversationId === conversationId && data.userId !== getCurrentUserId()) {
                    const typingIndicator = document.getElementById('typingIndicator');
                    const typingText = typingIndicator?.querySelector('.typing-text');
                    
                    if (data.isTyping) {
                        if (typingIndicator) typingIndicator.style.display = 'flex';
                        if (typingText) typingText.textContent = `${data.userName || 'User'} is typing...`;
                        
                        // Auto-scroll to show typing indicator
                        const chatMessages = document.getElementById('chatMessages');
                        if (chatMessages) {
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    } else {
                        if (typingIndicator) typingIndicator.style.display = 'none';
                    }
                }
            };
            WebSocketClient.on('user_typing', typingHandler);
            currentConversationWebSocketHandlers['user_typing'] = typingHandler;
        }
        
        // Poll for other user's typing status (fallback if WebSocket not available)
        function startTypingPoll() {
            if (WebSocketClient.isConnected()) {
                // Use WebSocket for typing indicators, no polling needed
                return;
            }
            
            if (typingPollInterval) {
                clearInterval(typingPollInterval);
            }
            
            typingPollInterval = setInterval(async () => {
                if (!currentConversationId) return;
                
                try {
                    const response = await apiFetch(`/typing?conversation_id=${currentConversationId}`, {
                        silent: true,
                        retry: false
                    });
                    
                    if (response.success) {
                        const typingIndicator = document.getElementById('typingIndicator');
                        const typingText = typingIndicator?.querySelector('.typing-text');
                        
                        if (response.is_typing && response.user_name) {
                            if (typingIndicator) typingIndicator.style.display = 'flex';
                            if (typingText) typingText.textContent = `${response.user_name} is typing...`;
                            
                            // Auto-scroll to show typing indicator
                            const chatMessages = document.getElementById('chatMessages');
                            if (chatMessages) {
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                        } else {
                            if (typingIndicator) typingIndicator.style.display = 'none';
                        }
                    }
                } catch (error) {
                    // Silently fail - typing indicator is not critical
                    console.warn('Failed to check typing status:', error);
                }
            }, 2000); // Check every 2 seconds
        }
        
        // Stop typing poll
        function stopTypingPoll() {
            if (typingPollInterval) {
                clearInterval(typingPollInterval);
                typingPollInterval = null;
            }
            
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) typingIndicator.style.display = 'none';
        }
        
        // Modify selectConversation to setup typing indicator
        const originalSelectConversation = window.selectConversation;
        window.selectConversation = function(conversationId) {
            if (originalSelectConversation) {
                originalSelectConversation(conversationId);
            }
            setupTypingIndicator();
            startTypingPoll();
        };
        
        // Modify sendMessage to stop typing
        const originalSendMessage = window.sendMessage;
        window.sendMessage = async function() {
            // Stop typing before sending
            if (isTyping && currentConversationId) {
                const user = Auth.getUser();
                const userName = user ? user.name : 'User';
                
                if (WebSocketClient.isConnected()) {
                    WebSocketClient.sendTyping(currentConversationId, false, userName);
                } else {
                    apiFetch('/typing', {
                        method: 'POST',
                        body: JSON.stringify({
                            conversation_id: currentConversationId,
                            is_typing: false
                        }),
                        silent: true,
                        retry: false
                    }).catch(() => {});
                }
                isTyping = false;
            }
            if (typingTimeout) {
                clearTimeout(typingTimeout);
                typingTimeout = null;
            }
            if (originalSendMessage) {
                await originalSendMessage();
            }
        };
        
        // Setup typing indicator on page load if conversation is already selected
        setTimeout(() => {
            if (currentConversationId) {
                setupTypingIndicator();
                startTypingPoll();
            }
        }, 1000);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (messagePollInterval) {
                clearInterval(messagePollInterval);
            }
            if (typingPollInterval) {
                clearInterval(typingPollInterval);
            }
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            // Send stop typing status
            if (isTyping && currentConversationId) {
                apiFetch('/typing', {
                    method: 'POST',
                    body: JSON.stringify({
                        conversation_id: currentConversationId,
                        is_typing: false
                    }),
                    silent: true,
                    retry: false
                }).catch(() => {});
            }
        });
    </script>
</body>
</html>